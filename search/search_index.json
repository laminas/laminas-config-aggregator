{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"../../README.md","title":"Home"},{"location":"caching/","text":"Caching Merging configuration on every request is not performant, particularly when using many configuration files. As such, laminas-config-aggregator also provides the ability to enable a filesystem-based configuration cache. To enable the configuration cache, pass a cache file name as the second parameter to the ConfigAggregator constructor: use Laminas\\ConfigAggregator\\ArrayProvider; use Laminas\\ConfigAggregator\\ConfigAggregator; use Laminas\\ConfigAggregator\\PhpFileProvider; $aggregator = new ConfigAggregator( [ new ArrayProvider([ConfigAggregator::ENABLE_CACHE =&gt; true]), new PhpFileProvider('*.global.php'), ], 'data/config-cache.php' ); When a cache file is specified, you will also need to add the config_cache_enabled key (which you can also specify via the ConfigAggregator::ENABLE_CACHE constant) somewhere within one of your configuration providers, and set it to boolean true . Using this approach, if you were to use the globbing pattern {{,*.}global,{,*.}local}.php (or similar) with the PhpFileProvider , you could drop a file named enable-cache.local.php into your production deployment with the following contents in order to enable configuration caching in production: &lt;?php use Laminas\\ConfigAggregator\\ConfigAggregator; return [ ConfigAggregator::ENABLE_CACHE =&gt; true, ]; When caching is enabled, the ConfigAggregator does not iterate config providers. Because of that it is very fast, but after it is enabled, you cannot make any changes to configuration without clearing the cache. Caching should be used only in a production environment , and your deployment process should clear the cache. You can control the permissions used when creating the cache file by passing the file mode in the ConfigAggregator::CACHE_FILEMODE configuration. Use this if your config contains sensitive information such as database passwords: use Laminas\\ConfigAggregator\\ArrayProvider; use Laminas\\ConfigAggregator\\ConfigAggregator; use Laminas\\ConfigAggregator\\PhpFileProvider; $aggregator = new ConfigAggregator( [ new ArrayProvider([ ConfigAggregator::ENABLE_CACHE =&gt; true, ConfigAggregator::CACHE_FILEMODE =&gt; 0600 // only owner can read and write ]), new PhpFileProvider('*.global.php'), ], 'data/config-cache.php' ); Note that mode is an octal value. To ensure the expected operation, you need to prefix the file mode with a zero (e.g. 0644 ).","title":"Caching"},{"location":"caching/#caching","text":"Merging configuration on every request is not performant, particularly when using many configuration files. As such, laminas-config-aggregator also provides the ability to enable a filesystem-based configuration cache. To enable the configuration cache, pass a cache file name as the second parameter to the ConfigAggregator constructor: use Laminas\\ConfigAggregator\\ArrayProvider; use Laminas\\ConfigAggregator\\ConfigAggregator; use Laminas\\ConfigAggregator\\PhpFileProvider; $aggregator = new ConfigAggregator( [ new ArrayProvider([ConfigAggregator::ENABLE_CACHE =&gt; true]), new PhpFileProvider('*.global.php'), ], 'data/config-cache.php' ); When a cache file is specified, you will also need to add the config_cache_enabled key (which you can also specify via the ConfigAggregator::ENABLE_CACHE constant) somewhere within one of your configuration providers, and set it to boolean true . Using this approach, if you were to use the globbing pattern {{,*.}global,{,*.}local}.php (or similar) with the PhpFileProvider , you could drop a file named enable-cache.local.php into your production deployment with the following contents in order to enable configuration caching in production: &lt;?php use Laminas\\ConfigAggregator\\ConfigAggregator; return [ ConfigAggregator::ENABLE_CACHE =&gt; true, ]; When caching is enabled, the ConfigAggregator does not iterate config providers. Because of that it is very fast, but after it is enabled, you cannot make any changes to configuration without clearing the cache. Caching should be used only in a production environment , and your deployment process should clear the cache. You can control the permissions used when creating the cache file by passing the file mode in the ConfigAggregator::CACHE_FILEMODE configuration. Use this if your config contains sensitive information such as database passwords: use Laminas\\ConfigAggregator\\ArrayProvider; use Laminas\\ConfigAggregator\\ConfigAggregator; use Laminas\\ConfigAggregator\\PhpFileProvider; $aggregator = new ConfigAggregator( [ new ArrayProvider([ ConfigAggregator::ENABLE_CACHE =&gt; true, ConfigAggregator::CACHE_FILEMODE =&gt; 0600 // only owner can read and write ]), new PhpFileProvider('*.global.php'), ], 'data/config-cache.php' ); Note that mode is an octal value. To ensure the expected operation, you need to prefix the file mode with a zero (e.g. 0644 ).","title":"Caching"},{"location":"config-post-processors/","text":"Post processors The ConfigAggregator can apply post processors to the merged configuration by aggregating \"config processors\" passed to its constructor. Each processor should be a PHP callable which consumes the merged configuration as its sole argument, and which then returns the processed configuration array. $providers = [ function () { return ['foo' =&gt; 'bar']; }, new PhpFileProvider('*.global.php'), ]; $processors = [ function (array $config) { return $config + ['post-processed' =&gt; true]; }, ]; $aggregator = new ConfigAggregator($providers, null, $processors); var_dump($aggregator-&gt;getMergedConfig()); Output from the example: array(2) { 'foo' =&gt; string(3) \"bar\" 'post-processed' =&gt; bool(true) } If the processor is a class name, the aggregator automatically instantiates it before invoking it; as such, any class name you use as a config provider must also define __invoke() , and that method must return an array and may consume the merged configuration as a parameter. Post processors can be used to mimic tools such as the Symfony configuration parameter system . As an example, you can specify a config processor which consumes the merged configuration and resolves templated parameters to other parameters within your configuration. Post processor examples Symfony ParameterBag Post Processor The following example resolves templated parameters to either other parameters within your configuration, or a static set of substitutions. Templated parameters have the format %&lt;config_key&gt;% ; . characters indicate an additional level of nesting. If you want to provide configuration parameters with % in the value, you must escape any occurences of % by using another % ; as examples, %%bar or %%foo%% . In the following example, we define a provider that returns a nested array of configuration. We then define additional parameters and pass them to a Symfony DI ParameterBag , which we develop a closure over. This closure checks for parameters in the passed configuration itself, and then attempts to resolve all configuration values based on the parameters in the ParameterBag . $provider = [ function () { return [ 'session' =&gt; [ 'cookie_domain' =&gt; '%cookie_domain%', ], 'tracking' =&gt; [ 'cookie_domain' =&gt; '%cookie_domain%', ], // Will be converted to %foo% after resolving 'config_parameter_with_percent' =&gt; '%%foo%%', ]; }, ]; $parameters = [ 'cookie_domain' =&gt; 'example.com', ]; $bag = new \\Symfony\\Component\\DependencyInjection\\ParameterBag\\ParameterBag($parameters); $resolver = function (array $config) use ($bag) { $parametersFromConfiguration = isset($config['parameters']) ? $config['parameters'] : []; $bag-&gt;add($parametersFromConfiguration); // Resolve parameters which probably base on parameters $bag-&gt;resolve(); // Replace all parameters within the configuration $resolved = $bag-&gt;resolveValue($config); $resolved['parameters'] = $bag-&gt;all(); return $bag-&gt;unescapeValue($resolved); }; $aggregator = new ConfigAggregator($provider, null, [ $resolver, ]); var_dump($aggregator-&gt;getMergedConfig()); The above would result in the following when complete: array(2) { 'session' =&gt; array(1) { 'cookie_domain' =&gt; string(11) \"example.com\" } 'tracking' =&gt; array(1) { 'cookie_domain' =&gt; string(11) \"example.com\" } 'config_parameter_with_percent' =&gt; string(7) \"%foo%\" } 'parameters' =&gt; array(1) { 'cookie_domain' =&gt; string(11) \"example.com\" } } There is an extension for this feature available via the package laminas/laminas-config-aggregator-parameters : $ composer require laminas/laminas-config-aggregator-parameters","title":"Post Processors"},{"location":"config-post-processors/#post-processors","text":"The ConfigAggregator can apply post processors to the merged configuration by aggregating \"config processors\" passed to its constructor. Each processor should be a PHP callable which consumes the merged configuration as its sole argument, and which then returns the processed configuration array. $providers = [ function () { return ['foo' =&gt; 'bar']; }, new PhpFileProvider('*.global.php'), ]; $processors = [ function (array $config) { return $config + ['post-processed' =&gt; true]; }, ]; $aggregator = new ConfigAggregator($providers, null, $processors); var_dump($aggregator-&gt;getMergedConfig()); Output from the example: array(2) { 'foo' =&gt; string(3) \"bar\" 'post-processed' =&gt; bool(true) } If the processor is a class name, the aggregator automatically instantiates it before invoking it; as such, any class name you use as a config provider must also define __invoke() , and that method must return an array and may consume the merged configuration as a parameter. Post processors can be used to mimic tools such as the Symfony configuration parameter system . As an example, you can specify a config processor which consumes the merged configuration and resolves templated parameters to other parameters within your configuration.","title":"Post processors"},{"location":"config-post-processors/#post-processor-examples","text":"","title":"Post processor examples"},{"location":"config-providers/","text":"Config providers The ConfigAggregator works by aggregating \"config providers\" passed to its constructor. Each provider should be a callable, returning a configuration array (or a PHP generator) to be merged. $aggregator = new ConfigAggregator([ function () { return ['foo' =&gt; 'bar']; }, new PhpFileProvider('*.global.php'), ]); var_dump($aggregator-&gt;getMergedConfig()); If the provider is a class name, the aggregator automatically instantiates it before invoking it; as such, any class name you use as a config provider must also define __invoke() , and that method must return an array. This can be used to mimic the Laminas module system: you can specify a list of config providers from different packages, and aggregated configuration will be available to your application. As a library owner, you can distribute your own configuration providers that provide default values for use with your library. As an example: class ApplicationConfig { public function __invoke() { return ['foo' =&gt; 'bar']; } } $aggregator = new ConfigAggregator([ ApplicationConfig::class, new PhpFileProvider('*.global.php'), ]); var_dump($aggregator-&gt;getMergedConfig()); Output from both examples will be the same: array(4) { 'foo' =&gt; string(3) \"bar\" 'db' =&gt; array(1) { 'dsn' =&gt; string(9) \"mysql:...\" } 'cache_storage' =&gt; string(5) \"redis\" 'redis' =&gt; array(0) { } } Generators Config providers can be written as generators. This way, a single callable can provide multiple configurations: use Laminas\\ConfigAggregator\\ConfigAggregator; use Laminas\\Stdlib\\Glob; $aggregator = new ConfigAggregator([ function () { foreach (Glob::glob('data/*.global.php', Glob::GLOB_BRACE) as $file) { yield include $file; } }, ]); var_dump($aggregator-&gt;getMergedConfig()); The PhpFileProvider is implemented as a generator. Available config providers PhpFileProvider Loads configuration from PHP files returning arrays, such as this one: return [ 'db' =&gt; [ 'dsn' =&gt; 'mysql:...', ], ]; Wildcards are supported: use Laminas\\ConfigAggregator\\ConfigAggregator; use Laminas\\ConfigAggregator\\PhpFileProvider; $aggregator = new ConfigAggregator( [ new PhpFileProvider('config/*.global.php'), ] ); The example above will merge all matching files from the config/ directory. If you have files such as app.global.php or database.global.php in that directory, they will be loaded using this above lines of code. The provider also supports globbing . Globbing defaults to PHP's glob() function. However, if Laminas\\Stdlib\\Glob is available, it will use that to allow for cross-platform glob patterns, including brace notation: 'config/autoload/{{,*.}global,{,*.}local}.php' . Install laminas/laminas-stdlib to utilize this feature. LaminasConfigProvider Sometimes using plain PHP files may be not enough; you may want to build your configuration from multiple files of different formats, such as INI, JSON, YAML, or XML. laminas-config-aggregator allows you to do so via its LaminasConfigProvider . This feature requires first installing laminas-config: $ composer require laminas/laminas-config Once installed, you may use as many LaminasConfigProvider instances as you need: use Laminas\\ConfigAggregator\\ConfigAggregator; use Laminas\\ConfigAggregator\\LaminasConfigProvider; $aggregator = new ConfigAggregator( [ new LaminasConfigProvider('*.global.json'), new LaminasConfigProvider('database.local.ini'), ] ); These could even be combined into a single glob statement: $aggregator = new ConfigAggregator( [ new LaminasConfigProvider('*.global.json,database.local.ini'), ] ); LaminasConfigProvider accepts wildcards and globs, and autodetects the config type based on file extension. Some config readers (in particular, YAML) may need additional dependencies; please refer to the laminas-config manual for more details. LaminasModuleProvider To provide configuration using Module classes created for laminas/laminas-mvc applications, you can use the LaminasModuleProvider , via the package laminas/laminas-config-aggregator-modulemanager . This provider introspects the module class for its Module::getConfig() method as well as its Module::getServiceConfig() method (declared via the ServiceProviderInterface ). To use the extension, first install its package: $ composer require laminas/laminas-config-aggregator-modulemanager Once installed, you may use as many LaminasModuleProvider instances as you need: use Laminas\\ConfigAggregator\\ConfigAggregator; use Laminas\\ConfigAggregatorModuleManager\\LaminasModuleProvider; use ACME; $aggregator = new ConfigAggregator([ new LaminasModuleProvider(new ACME\\Module()), ]); LaminasModuleProvider accepts any object which represents a laminas-mvc module. For more details, please refer to the laminas-config-aggregator-modulemanager manual .","title":"Config Providers"},{"location":"config-providers/#config-providers","text":"The ConfigAggregator works by aggregating \"config providers\" passed to its constructor. Each provider should be a callable, returning a configuration array (or a PHP generator) to be merged. $aggregator = new ConfigAggregator([ function () { return ['foo' =&gt; 'bar']; }, new PhpFileProvider('*.global.php'), ]); var_dump($aggregator-&gt;getMergedConfig()); If the provider is a class name, the aggregator automatically instantiates it before invoking it; as such, any class name you use as a config provider must also define __invoke() , and that method must return an array. This can be used to mimic the Laminas module system: you can specify a list of config providers from different packages, and aggregated configuration will be available to your application. As a library owner, you can distribute your own configuration providers that provide default values for use with your library. As an example: class ApplicationConfig { public function __invoke() { return ['foo' =&gt; 'bar']; } } $aggregator = new ConfigAggregator([ ApplicationConfig::class, new PhpFileProvider('*.global.php'), ]); var_dump($aggregator-&gt;getMergedConfig()); Output from both examples will be the same: array(4) { 'foo' =&gt; string(3) \"bar\" 'db' =&gt; array(1) { 'dsn' =&gt; string(9) \"mysql:...\" } 'cache_storage' =&gt; string(5) \"redis\" 'redis' =&gt; array(0) { } }","title":"Config providers"},{"location":"config-providers/#generators","text":"Config providers can be written as generators. This way, a single callable can provide multiple configurations: use Laminas\\ConfigAggregator\\ConfigAggregator; use Laminas\\Stdlib\\Glob; $aggregator = new ConfigAggregator([ function () { foreach (Glob::glob('data/*.global.php', Glob::GLOB_BRACE) as $file) { yield include $file; } }, ]); var_dump($aggregator-&gt;getMergedConfig()); The PhpFileProvider is implemented as a generator.","title":"Generators"},{"location":"config-providers/#available-config-providers","text":"","title":"Available config providers"},{"location":"intro/","text":"Introduction laminas-config-aggregator is a lightweight library for managing application configuration. It was designed to be flexible in dev environments and fast in production. It supports loading and merging configuration from multiple sources: PHP files, arrays, or INI/YAML/XML files (using laminas-config ) It also provides the ability to post process the merged configuration to apply e.g. parameter handling like symfony/dependency-injection Basic usage The standalone ConfigAggregator can be used to merge PHP-based configuration files: use Laminas\\ConfigAggregator\\ConfigAggregator; use Laminas\\ConfigAggregator\\PhpFileProvider; $aggregator = new ConfigAggregator([ new PhpFileProvider('*.global.php'), ]); var_dump($aggregator-&gt;getMergedConfig()); Using this provider, each file should return a PHP array: // db.global.php return [ 'db' =&gt; [ 'dsn' =&gt; 'mysql:...', ], ]; // cache.global.php return [ 'cache_storage' =&gt; 'redis', 'redis' =&gt; [ ... ], ]; Result: array(3) { 'db' =&gt; array(1) { 'dsn' =&gt; string(9) \"mysql:...\" } 'cache_storage' =&gt; string(5) \"redis\" 'redis' =&gt; array(0) { ... } } Configuration is merged in the same order as it is passed, with later entries having precedence. Together with laminas-config , laminas-config-aggregator can be also used to load configuration in different formats, including YAML, JSON, XML, or INI: use Laminas\\ConfigAggregator\\ConfigAggregator; use Laminas\\ConfigAggregator\\LaminasConfigProvider; $aggregator = new ConfigAggregator([ new LaminasConfigProvider('config/*.{json,yaml,php}'), ]); You can also supply post processors for configuration. These are PHP callables that accept the merged configuration as an argument, do something with it, and return configuration on completion. This could be used, for example, to allow templating parameters that are used in multiple locations and resolving them to a single value later.","title":"Introduction"},{"location":"intro/#introduction","text":"laminas-config-aggregator is a lightweight library for managing application configuration. It was designed to be flexible in dev environments and fast in production. It supports loading and merging configuration from multiple sources: PHP files, arrays, or INI/YAML/XML files (using laminas-config ) It also provides the ability to post process the merged configuration to apply e.g. parameter handling like symfony/dependency-injection","title":"Introduction"},{"location":"intro/#basic-usage","text":"The standalone ConfigAggregator can be used to merge PHP-based configuration files: use Laminas\\ConfigAggregator\\ConfigAggregator; use Laminas\\ConfigAggregator\\PhpFileProvider; $aggregator = new ConfigAggregator([ new PhpFileProvider('*.global.php'), ]); var_dump($aggregator-&gt;getMergedConfig()); Using this provider, each file should return a PHP array: // db.global.php return [ 'db' =&gt; [ 'dsn' =&gt; 'mysql:...', ], ]; // cache.global.php return [ 'cache_storage' =&gt; 'redis', 'redis' =&gt; [ ... ], ]; Result: array(3) { 'db' =&gt; array(1) { 'dsn' =&gt; string(9) \"mysql:...\" } 'cache_storage' =&gt; string(5) \"redis\" 'redis' =&gt; array(0) { ... } } Configuration is merged in the same order as it is passed, with later entries having precedence. Together with laminas-config , laminas-config-aggregator can be also used to load configuration in different formats, including YAML, JSON, XML, or INI: use Laminas\\ConfigAggregator\\ConfigAggregator; use Laminas\\ConfigAggregator\\LaminasConfigProvider; $aggregator = new ConfigAggregator([ new LaminasConfigProvider('config/*.{json,yaml,php}'), ]); You can also supply post processors for configuration. These are PHP callables that accept the merged configuration as an argument, do something with it, and return configuration on completion. This could be used, for example, to allow templating parameters that are used in multiple locations and resolving them to a single value later.","title":"Basic usage"}]}